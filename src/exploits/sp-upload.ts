import { cleanRead, MDTrack, MemoryType, patch, Wireformat } from "netmd-js";
import { Exploit, VersionPropertyStore } from "../exploit";

// Exploit based on @Sir68k's work (https://github.com/Sir68k)
export class SPUpload extends Exploit {
    static _name = "SPUpload";

    public _policies = {
        stateManagerUnpatchLegal: true,
    };

    protected getPropertyStore(): VersionPropertyStore {
        return {
            fiqHandlerTypeAddress: {
                'S1.600': 0x02003eff + 208,
            },

            fiqHandlerAPatch0: {
                'S1.600': 0x0007f408,
            },
            fiqHandlerBPatch0: {
                'S1.600': 0x0007efec,
            },


            prepPatchCommon: {
                'S1.600': 0x00077c04,
            },
            fiqHandlerCommon1: {
                'S1.600': 0x0007f4e8,
            },
            fiqHandlerCommon2: {
                'S1.600': 0x0007f4ec,
            },
            
            trackType: {
                'S1.600': 0x000852b0,
            },


            fiqHandlerPatch0Contents: {
                'S*': new Uint8Array([0x00,0x00,0xa0,0xe1]),
            },
            fiqHandlerPatch1Contents: {
                'S*': new Uint8Array([0x14,0x80,0x80,0x03]),
            },
            fiqHandlerPatch2Contents: {
                'S*': new Uint8Array([0x14,0x90,0x80,0x03]),
            },
            prepPatchContents: {
                'S*': new Uint8Array([0x0D,0x31,0x01,0x60]),
            },
            trackTypeContents: {
                'S*': new Uint8Array([6,2,0,4]), // SP, LP2, LP4, MONO
            },
        }
    }

    variant = -1;

    async init(channels: 1 | 2) {
        await super.init();
        this.variant = (await cleanRead(
            this.factoryIface,
            this.getProperty("fiqHandlerTypeAddress"),
            1,
            MemoryType.MAPPED,
        ))[0];
        let addressA;

        if(this.variant !== 1){
            // Variant a
            ([addressA] = this.getProperties(
                "fiqHandlerAPatch0",
            ));
        }else{
            // Variant b
            ([addressA] = this.getProperties(
                "fiqHandlerBPatch0",
            ));
        }

        await patch(
            this.factoryIface,
            addressA,
            this.getProperty("fiqHandlerPatch0Contents"),
            this.stateManager.getIncrementalPatchNumber(),
            this.stateManager.getMaxPatchesAmount(),
        );
        await patch(
            this.factoryIface,
            this.getProperty("fiqHandlerCommon1"),
            this.getProperty("fiqHandlerPatch1Contents"),
            this.stateManager.getIncrementalPatchNumber(),
            this.stateManager.getMaxPatchesAmount(),
        );
        await patch(
            this.factoryIface,
            this.getProperty("fiqHandlerCommon2"),
            this.getProperty("fiqHandlerPatch2Contents"),
            this.stateManager.getIncrementalPatchNumber(),
            this.stateManager.getMaxPatchesAmount(),
        );
        await patch(
            this.factoryIface,
            this.getProperty("prepPatchCommon"),
            this.getProperty("prepPatchContents"),
            this.stateManager.getIncrementalPatchNumber(),
            this.stateManager.getMaxPatchesAmount(),
        );
        
        const trackTypeContents = this.getProperty("trackTypeContents");
        trackTypeContents[1] = channels === 1 ? 4 : 6;
        await patch(
            this.factoryIface,
            this.getProperty("trackType"),
            trackTypeContents,
            this.stateManager.getIncrementalPatchNumber(),
            this.stateManager.getMaxPatchesAmount(),
        );
    }

    prepareTrack(track: MDTrack) {
        // Transcribe the track and call session's method.
        
        // In order to re-align the data with the DRAM buffer,
        // (floor(2332 / 105) + 1) * 105 - 2332 padding bytes need to be added

        const padding = 100;
        const paddingArray = new Uint8Array(padding).fill(0);
        
        const raw = new Uint8Array(track.data);
        const originalLength = raw.length;
        const slices: Uint8Array[] = [];
        for(let i = 0; i<originalLength; i += 2332){
            slices.push(raw.subarray(i, i + 2332));
            slices.push(paddingArray);
        }
        track = new MDTrack(
            track.title,
            Wireformat.l105kbps,
            concatUint8Arrays(slices).buffer,
            track.chunkSize,
            track.fullWidthTitle,
            track.encryptPacketsIterator
        );
        track.getFrameCount = () => originalLength / 212;

        return track;
    }

}

function concatUint8Arrays(args: Uint8Array[]) {
    let totalLength = 0;
    for (let a of args) {
        totalLength += a.length;
    }

    let res = new Uint8Array(totalLength);

    let offset = 0;
    for (let a of args) {
        res.set(a, offset);
        offset += a.length;
    }
    return res;
}
