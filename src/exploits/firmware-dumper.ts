import { cleanRead, MemoryOpenType, MemoryType } from 'netmd-js';
import { concatUint8Arrays } from 'netmd-js/dist/utils';
import { Exploit, VersionPropertyStore } from '../exploit';
import { findBytes, formatUIntQuery } from '../utils';

export class FirmwareDumper extends Exploit {
    public static _name = 'FirmwareDumper';

    protected getPropertyStore(): VersionPropertyStore {
        return {
            romSize: {
                'A*': 0x70000,
                'B*': 0xa0000,
            },
            ramSize: {
                'A*': 0x4800,
                'B*': 0x9000,
            },
        };
    }

    async readFirmware(callback: (progress: { type: 'RAM' | 'ROM'; readBytes: number; totalBytes: number }) => void = () => {}) {
        // This exploit works by first reading the device's RAM using legal factory mode commands
        // then, in that RAM image, the exploit finds the USB command buffer, which is followed
        // by the allowed memory access ranges written by 'changeMemoryState'. The factory mode
        // allows any RAM address to be overwritten with any value, so nothing is stopping us
        // from rewriting these ranges to zeros, allowing us to start reading at mapped memory
        // address 0x00000000 - the flash ROM - the firmware.

        const [romSize, ramSize] = this.getProperties('romSize', 'ramSize');
        let memorySlices: Uint8Array[] = [];
        callback({ type: 'RAM', readBytes: 0, totalBytes: ramSize });
        for (let i = 0; i < ramSize; i += 0x10) {
            memorySlices.push(await cleanRead(this.factoryIface, 0x02000000 + i, 0x10, MemoryType.MAPPED));
            callback({ type: 'RAM', readBytes: memorySlices.length * 0x10, totalBytes: ramSize });
        }
        callback({ type: 'ROM', readBytes: 0, totalBytes: romSize });
        let fullRam = concatUint8Arrays(...memorySlices);

        // Find the factory USB buffer. The allowed ranges should be right behind it.
        const usbBufferBeginning = new Uint8Array([0x00, 0x18, 0x21, 0x00, 0x00]);
        let offset = findBytes(fullRam, usbBufferBeginning);
        let foundRAMBoundsOffset = -1;
        while (offset !== -1) {
            let shouldStartHere = offset + 0x20;
            let possibleValue = Math.floor(shouldStartHere / 16) * 16 + 0x02000000;
            let calculated = formatUIntQuery('%<d', possibleValue);
            let broken = false;
            for (let i = 0; i < 4; i++) {
                if (calculated[i] !== fullRam[shouldStartHere + i]) {
                    broken = true;
                    break;
                }
            }
            if (!broken) {
                foundRAMBoundsOffset = shouldStartHere + 0x02000000;
                break;
            }
            offset = findBytes(fullRam, usbBufferBeginning, offset + usbBufferBeginning.length);
        }
        if (foundRAMBoundsOffset === -1) throw new Error('Cannot find the offset to the reading boundary');

        // Use the offset to rewrite the possible reading boundaries within the RAM.
        await this.factoryIface.changeMemoryState(foundRAMBoundsOffset, 0x10, MemoryType.MAPPED, MemoryOpenType.READ_WRITE);
        await this.factoryIface.write(foundRAMBoundsOffset, new Uint8Array(Array(0x10).fill(0)), MemoryType.MAPPED);

        let firmwareSlices: Uint8Array[] = [];

        // Exploit the now extended boundary to read from 0x0 (flash ROM).
        for (let i = 0; i < romSize; i += 0x10) {
            firmwareSlices.push(await this.factoryIface.read(i, 0x10, MemoryType.MAPPED));
            callback({ type: 'ROM', readBytes: firmwareSlices.length * 0x10, totalBytes: romSize });
        }

        // Close 0x0, as the boundary has been rewritten to that address.
        await this.factoryIface.changeMemoryState(0x0, 0x10, MemoryType.MAPPED, MemoryOpenType.CLOSE);

        return concatUint8Arrays(...firmwareSlices);
    }
}
