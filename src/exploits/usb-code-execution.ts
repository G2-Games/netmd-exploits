import JSBI from 'jsbi';
import { formatQuery, patch, scanQuery } from 'netmd-js';
import { Exploit } from '../exploit';
import { formatUIntQuery } from '../utils';

export class USBCodeExecution extends Exploit {
    public static _name = 'USBCodeExecution';

    protected getPropertyStore() {
        return {
            onePatchAddress: {
                'B1.600': 0x0000e69c,
                'B1.300': 0x0000daa8,
            },
            onePatchValue: {
                'B1.600': new Uint8Array([0x13, 0x48, 0x00, 0x47]),
                'B1.300': new Uint8Array([0x13, 0x48, 0x00, 0x47]),
            },
            twoPatchAddress1: {
                'B1.300': 0x0000daa8,
            },
            twoPatchValue1: {
                'B1.300': new Uint8Array([0x00, 0x48, 0x00, 0x47]),
            },
            twoPatchAddress2: {
                'B1.300': 0x0000daac,
            },
            twoPatchValue2: {
                'B1.300': new Uint8Array([0x30, 0x10, 0x00, 0x02]),
            },
        };
    }

    public async init() {
        await super.init();
        // Check if the device has already been patched (f. ex. hard-patch)
        const reply = await this.execute(formatUIntQuery('0100a0e30000cfe51eff2fe1 00'));
        const resp = scanQuery(reply, '0100a0e30000cfe51eff2fe1 %b');
        if (JSBI.toNumber(resp[0] as JSBI) === 0) {
            if (this.getPropertyOrNull('onePatchAddress') !== null) {
                const [addr, val] = this.getProperties('onePatchAddress', 'onePatchValue');
                await patch(
                    this.factoryIface!,
                    addr,
                    val,
                    this.stateManager.getIncrementalPatchNumber(),
                    this.stateManager.getMaxPatchesAmount()
                );
            } else {
                // Fallback to two-patch system
                const [addr1, val1, addr2, val2] = this.getProperties(
                    'twoPatchAddress1',
                    'twoPatchValue1',
                    'twoPatchAddress2',
                    'twoPatchValue2'
                );
                await patch(
                    this.factoryIface!,
                    addr1,
                    val1,
                    this.stateManager.getIncrementalPatchNumber(),
                    this.stateManager.getMaxPatchesAmount()
                );
                await patch(
                    this.factoryIface!,
                    addr2,
                    val2,
                    this.stateManager.getIncrementalPatchNumber(),
                    this.stateManager.getMaxPatchesAmount()
                );
            }
        }
    }

    public async execute(code: Uint8Array) {
        const query = formatQuery('00 18d2 ff %*', code);
        // Use iface.netMd to talk to the interface directly
        // arbitrary code execution still returns 'Not Implemented', and would crash
        // netmd-js's NetMDInterface with NotImplementedError, this is a workaround.
        await this.iface.netMd.sendCommand(query);
        const { data } = await this.iface.netMd.readReply(query.byteLength + 1);
        const buffer = data!.buffer;
        const [newCode] = scanQuery(buffer, '08 18d2 ff %*');
        return newCode as Uint8Array;
    }
}
