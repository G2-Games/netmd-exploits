import { cleanWrite, display, DisplayMode, MemoryType } from 'netmd-js';
import { VersionPropertyStore } from '../../exploit';
import { formatUIntQuery } from '../../utils';
import { USBCodeExecution } from '../usb-code-execution';
import { AtracRecovery } from './atrac-recovery-interface';

export class CachedSectorAtracDownload extends AtracRecovery {
    public static _name = 'CachedSectorAtracDownload';

    protected getPropertyStore(): VersionPropertyStore {
        return {
            mainCode: {
                'B*': `
                    @fw_compat_bridge

                    ; Copy the payload from _payload to _address, ending when encountered _marker
                    ldr r0, _address
                    ldr r3, _marker
                    adr r1, _payload

                    loop:
                        ldr r2, [ r1 ], #4
                        cmp r2, r3
                        beq finish
                        str r2, [ r0 ], #4
                        b loop
                    finish:
                        ; Backup return address
                        mov r7, lr

                        ; Zero-out config - default to normal USB behavior
                        ldr r1, config
                        mov r0, #0
                        str r0, [ r1 ]

                        ; Zero-out ATRAC sector - start from sector 0
                        ldr r1, atrac_sector_address
                        mov r0, #0
                        str r0, [ r1 ]
                        
                        ; Edit the firmware - redirect USB reading to the code loaded at $residentCodeAddress
                        mov r5, #$patchSlot1
                        ldr r3, _patch0A
                        ldr r4, _patch0V
                        bl _patch
                        mov r5, #$patchSlot2
                        ldr r3, _patch1A
                        ldr r4, _patch1V
                        bl _patch
                        
                        ; Return to firmware
                        bx r7

                    _patch:
                        @patch
                    
                    _patch0A: .word $usbReadStandardResponse
                    _patch0V: .word 0x47104a00 ; THUMB binary - Jump to the address 4 bytes after this. ( ldr r2, [ pc ] bx r2 )
                    _patch1A: .word $usbReadStandardReponseNext
                    _patch1V: 
                    _address: .word $residentCodeAddress

                    _payload:
                        ; Load config - if it is set, redirect request to read disc and increment sector
                        ; Else handle default
                        ; Memory can still be altered via the factory mode, so the config flag can be rewritten when needed
                        ; to toggle between standard commands, and ATRAC recovery.
                        push { r3, r4, r5, r6, r7 }

                        ldr r0, config
                        ldr r0, [ r0 ]
                        cmp r0, #0
                        
                        ; Load default values
                        ; Z flag unchanged
                        ldr r0, ptr_discstruct
                        ldr r1, [ r0, #0x24 ]
                        ldr r0, g_usb_buff
                        
                        beq handleUnchanged

                        ; *config is != 0, supress standard USB reading and load ATRAC instead.

                        ; Load current ATRAC sector
                        ldr r0, atrac_sector_address
                        ldr r0, [ r0 ]

                        ; Backup the value, to increment it later
                        push { r0 }

                        ; Prepare other parameters for the DRAM read method.
                        mov r1, #0
                        ldr r2, g_alternative_buff
                        mov r3, #2352
                        
                        ; Backup LR - we still need to return to the firmware later
                        mov r7, lr
                        
                        ; Call the DRAM Read function
                        @blxar r4, $funcReadAtracDRAM

                        ; Restore the sector address, increment and write it back to RAM
                        pop { r0 }
                        add r0, r0, #1
                        ldr r1, atrac_sector_address 
                        str r0, [ r1 ]

                        ; Load arguments for usb_do_response, and restore the return address
                        ldr r0, g_alternative_buff
                        mov r1, #2352
                        mov lr, r7

                        handleUnchanged:
                            pop { r3, r4, r5, r6, r7 }
                            @bxar r2, $usb_do_response

                        config: .word $enabledFlagAddress
                        atrac_sector_address: .word $sectorToReadAddress
                        g_alternative_buff: .word $sectorBuffer
                        g_usb_buff: .word $g_usb_buff
                        ptr_discstruct: .word $g_DiscStateStruct

                    
                    .word 0x968CE9A2
                    .word 0x0000B48D ; ðŸ¥š
                    
                    _marker: .word 0xBADC0DE0 ; End of _payload. 
                `,
            },
            residentCodeAddress: {
                'B*': 0x02005f00,
            },
            enabledFlagAddress: {
                'B*': 0x02005500,
            },
            sectorToReadAddress: {
                'B*': 0x02005600,
            },
            sectorBuffer: {
                'B*': 0x02006f00,
            },

            funcReadAtracDRAM: {
                'B1.600': 0x0007e661,
                'B1.300': 0x00079ca1
            },
            usbReadStandardResponse: {
                'B1.600': 0x0000de4c,
                'B1.300': 0x0000d25c
            },
            usbReadStandardReponseNext: {
                'B1.600': 0x0000de50,
                'B1.300': 0x0000d260
            },

            patchSlot1: {
                '*': this.patchSlot1,
            },
            patchSlot2: {
                '*': this.patchSlot2,
            },
        };
    }

    currentTrack = -1;
    patchSlot1: number = -1;
    patchSlot2: number = -1;

    async init() {
        await super.init();
        this.patchSlot1 = this.stateManager.getIncrementalPatchNumber();
        this.patchSlot2 = this.stateManager.getIncrementalPatchNumber();
        const usbExecution = await this.stateManager.require(USBCodeExecution);
        await usbExecution.execute(this.assembleProperty('mainCode'));
    }

    async readNextSector(): Promise<Uint8Array> {
        if (this.currentTrack === -1) throw new Error('You need to startDownload() first');

        // As $mainCode rewrites the part of firmware responsible for handling `readReply`
        // on the device's side, this will always return the next sector
        return new Uint8Array((await this.iface.netMd.readReply(2352)).data!.buffer);
    }

    async setSectorToRead(sector: number): Promise<void> {
        if (this.currentTrack === -1) throw new Error('You need to startDownload() first');
        await cleanWrite(this.factoryIface, this.getProperty('sectorToReadAddress'), formatUIntQuery('%<d', sector), MemoryType.MAPPED);
    }

    async startDownload(track: number): Promise<void> {
        await display(this.stateManager.factoryIface, 'ACCESS', true);
        this.currentTrack = track;
        await cleanWrite(this.factoryIface, this.getProperty('enabledFlagAddress'), formatUIntQuery('%<d', 1), MemoryType.MAPPED);
    }

    async finishDownload(): Promise<void> {
        await this.factoryIface.setDisplayMode(DisplayMode.DEFAULT);
        await cleanWrite(this.factoryIface, this.getProperty('enabledFlagAddress'), formatUIntQuery('%<d', 0), MemoryType.MAPPED);
        this.currentTrack = -1;
    }
}
