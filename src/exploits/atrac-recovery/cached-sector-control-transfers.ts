import { cleanWrite, display, DisplayMode, MemoryType } from 'netmd-js';
import { VersionPropertyStore } from '../../exploit';
import { formatUIntQuery } from '../../utils';
import { USBCodeExecution } from '../usb-code-execution';
import { AtracRecovery } from './atrac-recovery-interface';

export class CachedSectorControlDownload extends AtracRecovery {
    public static _name = 'CachedSectorControlDownload';

    protected getPropertyStore(): VersionPropertyStore {
        return {
            mainCode: {
                'S*,R*': `
                    @fw_compat_bridge

                    ; Copy the payload from _payload to _address, ending when encountered _marker
                    ldr r0, _address
                    ldr r3, _marker
                    adr r1, _payload

                    loop:
                        ldr r2, [ r1 ], #4
                        cmp r2, r3
                        beq finish
                        str r2, [ r0 ], #4
                        b loop
                    finish:
                        ; Backup return address
                        mov r7, lr

                        ; Zero-out config - default to normal USB behavior
                        ldr r1, config
                        mov r0, #0
                        str r0, [ r1 ]

                        ; Zero-out ATRAC sector - start from sector 0
                        ldr r1, atrac_sector_address
                        mov r0, #0
                        str r0, [ r1 ]
                        
                        ; Edit the firmware - redirect USB reading to the code loaded at $residentCodeAddress
                        mov r5, #$patchSlot1
                        ldr r3, _patch0A
                        ldr r4, _patch0V
                        bl _patch
                        mov r5, #$patchSlot2
                        ldr r3, _patch1A
                        ldr r4, _patch1V
                        bl _patch
                        
                        ; Return to firmware
                        bx r7

                    _patch:
                        @patch
                    
                    _patch0A: .word $usbReadStandardResponse
                    _patch0V: .word 0x47104a00 ; THUMB binary - Jump to the address 4 bytes after this. ( ldr r2, [ pc ] bx r2 )
                    _patch1A: .word $usbReadStandardReponseNext
                    _patch1V: 
                    _address: .word $residentCodeAddress

                    _payload:
                        ; Load config - if it is set, redirect request to read disc and increment sector
                        ; Else handle default
                        ; Memory can still be altered via the factory mode, so the config flag can be rewritten when needed
                        ; to toggle between standard commands, and ATRAC recovery.
                        push { r3, r4, r5, r6, r7 }

                        ldr r0, config
                        ldr r0, [ r0 ]
                        cmp r0, #0
                        
                        ; Load default values
                        ; Z flag unchanged
                        ldr r0, ptr_discstruct
                        ldr r1, [ r0, #$discStructOffset ]
                        ldr r0, g_usb_buff
                        
                        beq handleUnchanged

                        ; *config is != 0, supress standard USB reading and load ATRAC instead.

                        ; Load current ATRAC sector
                        ldr r0, atrac_sector_address
                        ldr r0, [ r0 ]

                        ; Backup the value, to increment it later
                        push { r0 }

                        ; Prepare other parameters for the DRAM read method.
                        mov r1, #0
                        ldr r2, g_alternative_buff
                        mov r3, #2352
                        
                        ; Backup LR - we still need to return to the firmware later
                        mov r7, lr
                        
                        ; Call the DRAM Read function
                        @blxar r4, $funcReadAtracDRAM

                        ; Restore the sector address, increment and write it back to RAM
                        pop { r0 }
                        add r0, r0, #1
                        ldr r1, atrac_sector_address 
                        str r0, [ r1 ]

                        ; Load arguments for usb_do_response, and restore the return address
                        ldr r0, g_alternative_buff
                        mov r1, #2352
                        mov lr, r7

                        handleUnchanged:
                            pop { r3, r4, r5, r6, r7 }
                            @bxar r2, $usb_do_response

                        config: .word $enabledFlagAddress
                        atrac_sector_address: .word $sectorToReadAddress
                        g_alternative_buff: .word $sectorBuffer
                        g_usb_buff: .word $g_usb_buff
                        ptr_discstruct: .word $g_DiscStateStruct

                    
                    .word 0x968CE9A2
                    .word 0x0000B38D ; ðŸ¥š
                    
                    _marker: .word 0xBADC0DE0 ; End of _payload. 
                `,
            },
            residentCodeAddress: {
                'S*': 0x02005f00,
                'R*': 0x02003cd0,
            },
            enabledFlagAddress: {
                'S*': 0x02005500,
                'R*': 0x02003230,
            },
            sectorToReadAddress: {
                'S*': 0x02005600,
                'R*': 0x02003234,
            },
            sectorBuffer: {
                'S*': 0x02006f00,
                'R*': 0x02003240,
            },
            discStructOffset: {
                'S*': 0x24,
                'R*': 0x1c,
            },

            funcReadAtracDRAM_slow: { //primarily here for posterity
                'S1.600': 0x0007e661,
                'S1.500': 0x0007dbe1,
                'S1.400': 0x0007d521,
                'S1.300': 0x00079ca1,
                'S1.200': 0x00078489,
                'S1.100': 0x00077a7d,
                'S1.000': 0x0007e7f5,
            },
            funcReadAtracDRAM: {
                'S1.600': 0x000781fd,
                'S1.500': 0x00077805,
                'S1.400': 0x00077131,
                'S1.300': 0x00073a71,
                'S1.200': 0x000723bd,
                'S1.100': 0x00071a35,
                'S1.000': 0x00078365,

                'R1.100': 0x0005dc65, // Slow one
            },
            usbReadStandardResponse: { //handleReadStandardResponse
                'S1.600': 0x0000de4c,
                'S1.500': 0x0000dcec,
                'S1.400': 0x0000dca4,
                'S1.300': 0x0000d25c,
                'S1.200': 0x0000cfe8,
                'S1.100': 0x0000cf5c,
                'S1.000': 0x0000df34,

                'R1.100': 0x00056410,
            },
            usbReadStandardReponseNext: {
                'S1.600': 0x0000de50,
                'S1.500': 0x0000dcf0,
                'S1.400': 0x0000dca8,
                'S1.300': 0x0000d260,
                'S1.200': 0x0000cfec,
                'S1.100': 0x0000cf60,
                'S1.000': 0x0000df38,

                'R1.100': 0x00056414,
            },

            patchSlot1: {
                '*': this.patchSlot1,
            },
            patchSlot2: {
                '*': this.patchSlot2,
            },
        };
    }

    currentTrack = -1;
    patchSlot1: number = -1;
    patchSlot2: number = -1;

    async init() {
        await super.init();
        this.patchSlot1 = this.stateManager.getIncrementalPatchNumber();
        this.patchSlot2 = this.stateManager.getIncrementalPatchNumber();
        const usbExecution = await this.stateManager.require(USBCodeExecution);
        await usbExecution.execute(this.assembleProperty('mainCode'));
    }

    async readNextSector(): Promise<Uint8Array> {
        if (this.currentTrack === -1) throw new Error('You need to startDownload() first');

        // As $mainCode rewrites the part of firmware responsible for handling `readReply`
        // on the device's side, this will always return the next sector
        return new Uint8Array((await this.iface.netMd.readReply(2352)).data!.buffer);
    }

    async setSectorToRead(sector: number): Promise<void> {
        if (this.currentTrack === -1) throw new Error('You need to startDownload() first');
        await cleanWrite(this.factoryIface, this.getProperty('sectorToReadAddress'), formatUIntQuery('%<d', sector), MemoryType.MAPPED);
    }

    async startDownload(track: number): Promise<void> {
        if(!this.stateManager.versionCode.startsWith("R")) await display(this.stateManager.factoryIface, 'ACCESS', true);
        this.currentTrack = track;
        await cleanWrite(this.factoryIface, this.getProperty('enabledFlagAddress'), formatUIntQuery('%<d', 1), MemoryType.MAPPED);
    }

    async finishDownload(): Promise<void> {
        if(!this.stateManager.versionCode.startsWith("R")) await this.factoryIface.setDisplayMode(DisplayMode.DEFAULT);
        await cleanWrite(this.factoryIface, this.getProperty('enabledFlagAddress'), formatUIntQuery('%<d', 0), MemoryType.MAPPED);
        this.currentTrack = -1;
    }
}
