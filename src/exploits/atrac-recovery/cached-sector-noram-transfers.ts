import { display, DisplayMode } from 'netmd-js';
import { concatUint8Arrays } from 'netmd-js/dist/utils';
import { VersionPropertyStore } from '../../exploit';
import { formatUIntQuery } from '../../utils';
import { USBCodeExecution } from '../usb-code-execution';
import { AtracRecovery } from './atrac-recovery-interface';

export class CachedSectorNoRamControlDownload extends AtracRecovery {
    public static _name = 'CachedSectorNoRamControlDownload';

    protected getPropertyStore(): VersionPropertyStore {
        return {
            code: {
                '*': `
                    ; Needs: subsectorStart, sector, cLength
                    push { r3, r4, lr }

                    @fw_compat_bridge

                    ldr r0, g_DiscStateStruct
                    ldr r1, length
                    add r1, r1, #<%cLength + 4>
                    str r1, [ r0, #$discStructOffset ]
                    str r1, [ r0, #<$discStructOffset - 0x4> ]

                    ; Prepare arguments for DRAM read call 'read_dram(%sector, %subsectorStart, &atrac, 392);'
                    ldr r0, #sector
                    ldr r1, #subsectorStart
                    adr r2, atrac
                    ldr r3, length

                    ; Call the DRAM Read function
                    @blxar r4, $read_atrac_dram
                    
                    ; Restore registers and return to firmware.
                    pop { r3, r4, lr }
                    bx lr

                    @bridge word g_DiscStateStruct
                    
                    sector: .word 0
                    subsectorStart: .word 0
                    length: .word 0
                    atrac:
                `,
            },
            discStructOffset: {
                'S*': 0x24,
                'R1.000,R1.100': 0x1c,
                'R1.200,R1.300,R1.400': 0x18,
            }
        };
    }

    currentTrack = -1;
    sector = 0;

    codeLength = this.assembleProperty("code", { cLength: 0 }).length;
    codeTemplate = this.assembleProperty("code", { cLength: this.codeLength }).slice(0, -12);

    async readNextSector(): Promise<Uint8Array> {
        if (this.currentTrack === -1) throw new Error('You need to startDownload() first');

        const exec = await this.stateManager.require(USBCodeExecution);
        const readPart = async (subsectorStart: number, length: number) => {
            const full = await exec.execute(concatUint8Arrays(
                this.codeTemplate,
                formatUIntQuery("%<d", this.sector),
                formatUIntQuery("%<d", subsectorStart),
                formatUIntQuery("%<d", length),
            ), length + this.codeLength + 4);
            return full.slice(this.codeLength);
        }
        const subArrays: Uint8Array[] = [];
        let rem = 2352;
        while(rem > 0){
            const subSector = await readPart(2352 - rem, Math.min(rem, 512 - 8 - this.codeLength));
            subArrays.push(subSector);
            rem -= subSector.length;
        }
        ++this.sector;
        return concatUint8Arrays(...subArrays);
    }

    async setSectorToRead(sector: number): Promise<void> {
        this.sector = sector;
    }

    async startDownload(track: number): Promise<void> {
        if (!this.stateManager.device.versionCode.startsWith('R')) await display(this.stateManager.factoryIface, 'ACCESS', true);
        this.currentTrack = track;
    }

    async finishDownload(): Promise<void> {
        if (!this.stateManager.device.versionCode.startsWith('R')) await this.factoryIface.setDisplayMode(DisplayMode.DEFAULT);
        this.currentTrack = -1;
    }
}
