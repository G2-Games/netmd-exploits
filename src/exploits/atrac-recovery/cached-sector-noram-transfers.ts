import { display, DisplayMode } from 'netmd-js';
import { concatUint8Arrays } from 'netmd-js/dist/utils';
import { VersionPropertyStore } from '../../exploit';
import { USBCodeExecution } from '../usb-code-execution';
import { AtracRecovery } from './atrac-recovery-interface';

export class CachedSectorNoRamControlDownload extends AtracRecovery {
    public static _name = 'CachedSectorNoRamControlDownload';

    protected getPropertyStore(): VersionPropertyStore {
        return {
            code: {
                '*': `
                    ; Needs: subsectorStart, length, sector, cLength

                    @fw_compat_bridge
                    push { r3, r4, lr }
                    
                    ldr r0, g_DiscStateStruct
                    mov r1, #%length
                    add r1, r1, #%cLength
                    str r1, [ r0, #$discStructOffset ]
                    str r1, [ r0, #$discStructOffset1 ]

                    mov r0, #%sector
                    mov r1, #%subsectorStart
                    adr r2, atrac
                    mov r3, #%length

                    ; Call the DRAM Read function
                    @blxar r4, $read_atrac_dram

                    pop { r3, r4, lr}
                    bx lr
                    
                    @bridge word g_DiscStateStruct
                    atrac:
                `,
            },
            discStructOffset: {
                'S*': 0x24,
                'R1.000,R1.100': 0x1c,
                'R1.200,R1.300,R1.400': 0x18,
            },
            discStructOffset1: {
                'S*': 0x20,
                'R1.000,R1.100': 0x18,
                'R1.200,R1.300,R1.400': 0x14,
            },
        };
    }

    currentTrack = -1;
    sector = 0;

    codeLength = this.assembleProperty("code", {
        length: 0,
        sector: 0,
        subsectorStart: 0,
        cLength: 0,
    }).length;

    async readNextSector(): Promise<Uint8Array> {
        if (this.currentTrack === -1) throw new Error('You need to startDownload() first');

        const exec = await this.stateManager.require(USBCodeExecution);
        const readPart = async (subsectorStart: number, length: number) => {
            return (await exec.execute(this.assembleProperty("code", {
                length: length + 4,
                sector: this.sector,
                subsectorStart: subsectorStart / 4,
                cLength: this.codeLength,
            }), length + 4 + this.codeLength)).subarray(this.codeLength);
        }
        const subArrays = [];
        let rem = 2352;
        while(rem > 0){
            const subSector = await readPart(2352-rem, Math.min(512 - 4 - this.codeLength, rem));
            subArrays.push(subSector);
            rem -= subSector.length;
        }
        ++this.sector;
        return concatUint8Arrays(...subArrays);
    }

    async setSectorToRead(sector: number): Promise<void> {
        this.sector = sector;
    }

    async startDownload(track: number): Promise<void> {
        if (!this.stateManager.device.versionCode.startsWith('R')) await display(this.stateManager.factoryIface, 'ACCESS', true);
        this.currentTrack = track;
    }

    async finishDownload(): Promise<void> {
        if (!this.stateManager.device.versionCode.startsWith('R')) await this.factoryIface.setDisplayMode(DisplayMode.DEFAULT);
        this.currentTrack = -1;
    }
}
