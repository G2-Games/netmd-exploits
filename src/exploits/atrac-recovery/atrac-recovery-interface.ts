import { concatUint8Arrays, createAeaHeader, createWavHeader, sleep } from 'netmd-js/dist/utils';
import { Exploit } from '../../exploit';
import { arrayShallowEquals } from '../../utils';
import { DiscFormat, readUTOCSector } from 'netmd-js';
import { getTitleByTrackNumber, ModeFlag, parseTOC } from 'netmd-tocmanip';

interface TimeRepresentation {
    low: number;
    high: number;
    type: number;
}

// I have copied this code from the firmware. The conversion
// of "LP / Mono" time to "SP" time happens on these "TimeRepresentation" objects.
function timeToRepresentation(seconds: number) {
    let unk = Math.floor((seconds * 1566) / 100);
    return {
        low: unk & 0b00011111,
        high: (unk >> 5) & 0xffff,
        type: (unk & 1) == 0 ? 0 : 6,
    };
}

function representationToTime({ low, high }: TimeRepresentation) {
    let unk = (high << 5) | low;
    let seconds = Math.floor((unk * 100) / 1566);
    return seconds;
}

function translateRepresentationToLP4(time: TimeRepresentation) {
    let newHigh = time.high >> 2,
        newLow = (time.high & 3) * 0x20 + (time.low >> 2),
        newType = (time.low & 3) * 0xb + (time.type >> 2);
    if (5 < newType && newLow * 1 == 0) {
        newLow += 1;
    }
    if (0x1f < newLow) {
        newLow -= 0x20;
        newHigh += 1;
    }
    time.high = newHigh;
    time.low = newLow;
    time.type = newType;
}

function translateRepresentationToLP2Mono(time: TimeRepresentation) {
    let newHigh = time.high >> 1,
        newLow = (time.high & 1) * 0x20 + (time.low >> 1),
        newType = ((time.low << 0x1f) >> 0x1f) * -0xb + (time.type >> 1);
    if (5 < newType && (newLow & 1) == 0) {
        newLow += 1;
    }
    if (0x1f < newLow) {
        newLow -= 0x20;
        newHigh += 1;
    }
    time.high = newHigh;
    time.low = newLow;
    time.type = newType;
}

function translateRepresentationFromLP4(time: TimeRepresentation) {
    let newLow, newHigh, newType, tempNewHigh, tempNewLow;

    tempNewLow = 0;
    tempNewHigh = time.high << 2;
    newHigh = tempNewHigh;

    for (newType = time.type * 4; 10 < newType; newType -= 0xb) tempNewLow += 2;
    for (tempNewLow = ((time.low >> 1) << 1) * 4; 0x1f < tempNewLow; tempNewLow -= 0x20) {
        tempNewHigh += 1;
        newHigh = tempNewHigh;
    }
    newLow = tempNewLow;
    if (5 < newType) {
        newLow |= 1;
    }
    time.type = newType;
    time.low = newLow;
    time.high = newHigh;
}

function translateRepresentationFromLP2Mono(time: TimeRepresentation) {
    let newLow, newHigh, newType, tempNewHigh, tempNewLow;

    tempNewLow = 0;
    tempNewHigh = time.high << 1;
    newHigh = tempNewHigh;

    for (newType = time.type * 2; 10 < newType; newType -= 0xb) tempNewLow += 2;
    for (tempNewLow = ((time.low >> 1) << 1) * 2; 0x1f < tempNewLow; tempNewLow -= 0x20) {
        tempNewHigh += 1;
        newHigh = tempNewHigh;
    }
    newLow = tempNewLow;
    if (5 < newType) {
        newLow |= 1;
    }
    time.type = newType;
    time.low = newLow;
    time.high = newHigh;
}

export abstract class AtracRecovery extends Exploit {
    public static _name = 'AtracRecovery';
    protected abstract readNextSector(): Promise<Uint8Array>;
    protected abstract setSectorToRead(sector: number): Promise<void>;

    protected abstract startDownload(track: number): Promise<void>;
    protected abstract finishDownload(): Promise<void>;

    async downloadTrack(
        track: number,
        progressCallback?: (data: { sectorsRead: number; totalSectors: number; action: 'READ' | 'SEEK'; sector?: string }) => void
    ): Promise<Uint8Array> {
        let finalData: Uint8Array[] = [];
        try {
            // Get info about the track - what format is it and what's the final sector
            const sector0 = await readUTOCSector(this.stateManager.factoryIface, 0);

            const toc = parseTOC(sector0);
            const trackRootFragment = toc.trackFragmentList[toc.trackMap[track + 1]];
            const formatStr =
                ((trackRootFragment.mode & ModeFlag.F_STEREO) !== 0 ? '1' : '0') +
                ((trackRootFragment.mode & ModeFlag.F_SP_MODE) !== 0 ? '1' : '0');

            let format = {
                '00': 'LP4',
                '10': 'LP2',
                '11': 'SPS',
                '01': 'SPM',
            }[formatStr]!;

            const createHeader = async () => {
                if (format.startsWith('LP')) {
                    return createWavHeader(
                        format === 'LP2' ? DiscFormat.lp2 : DiscFormat.lp4,
                        Array.from(finalData).reduce((a, b) => (a += b.length), 0)
                    );
                } else {
                    // We might as well give it the correct name
                    const sector1 = await readUTOCSector(this.stateManager.factoryIface, 1);
                    const nameToc = parseTOC(null,  sector1);
                    const name = getTitleByTrackNumber(nameToc, track + 1);
                    return createAeaHeader(name, ((trackRootFragment.mode & ModeFlag.F_STEREO) !== 0) ? 2 : 1);
                }
            }

            let lastFragment = trackRootFragment;
            let allSectors = 0;
            while (lastFragment.link !== 0) {
                allSectors +=
                    lastFragment.end.cluster * 32 + lastFragment.end.sector - (lastFragment.start.cluster * 32 + lastFragment.start.sector);
                if(lastFragment.end.group !== 0) allSectors += 1;
                lastFragment = toc.trackFragmentList[lastFragment.link];
            }
            allSectors +=
                lastFragment.end.cluster * 32 + lastFragment.end.sector - (lastFragment.start.cluster * 32 + lastFragment.start.sector);
            if(lastFragment.end.group !== 0) allSectors += 1;
            let finalAddress = lastFragment.end;

            await this.iface.gotoTrack(track);
            await this.startDownload(track);
            await this.setSectorToRead(0);

            if (progressCallback)
                progressCallback({
                    sectorsRead: finalData.length,
                    totalSectors: allSectors,
                    action: 'SEEK',
                });

            // TODO
            // Use tron_twai_task to freeze the USB task until a correct flag is emitted
            await new Promise((res) => setTimeout(res, 10000)); // Wait for the DRAM cache to fill up.

            // This is experimental code. It might not work in all cases.
            let sector = 0;

            let sectorPositionsRead: number[][] = [];

            while (sector < 0xfff) {
                if(finalData.length === allSectors){
                    console.log('Dumping complete!');
                    await this.finishDownload();
                    return concatUint8Arrays(await createHeader(), ...finalData);
                }
                let sectorContent = await this.readNextSector();
                sector++;

                const sectorMetadata = Array.from(sectorContent.slice(0, 20));
                const lastThree = sectorMetadata.slice(sectorMetadata.length - 3);
                const currentPosition = sectorMetadata.slice(sectorMetadata.length - 8, sectorMetadata.length - 5);

                // console.log(`Read sector 0x${sector.toString(16)} of DRAM. It contains the disc sector 0x${currentPosition.map(n => n.toString(16).padStart(2, '0')).join('')}`);
                if (!arrayShallowEquals(lastThree, [0, 0, 0])) {
                    // We're past the ATRAC data and are reading garbage data from the device's DRAM.
                    // Calculate the time offset, move the head using standard netmd commands.
                    let originalSeconds = finalData.length * 0.064 - 1;
                    if (format != 'SPS') {
                        // It's not SP Stereo
                        // Use the reverse of the functions used in the gotoTrack handler within the firmware, to convert the "SP" time
                        // SP time   >>   LP time   >>   SP time
                        // \_____/        \______/       \_____/
                        //   \/              \/             \/
                        // local var     time given     time converted
                        //  seconds     to gotoTrack     back within
                        //                               the firmware
                        //                               (@0x00012526 for B1.600)
                        let representation = timeToRepresentation(originalSeconds);
                        switch (format) {
                            case 'SPM':
                            case 'LP2':
                                translateRepresentationFromLP2Mono(representation);
                                break;
                            case 'LP4':
                                translateRepresentationFromLP4(representation);
                                break;
                        }
                        originalSeconds = representationToTime(representation);
                        originalSeconds -= 3; // Safety margin.
                    } else {
                        originalSeconds -= 1; // Safety margin.
                    }
                    console.log(
                        `The sector read is not an ATRAC sector. Sectors read previously add up to ${originalSeconds} seconds. Jumping to that time`
                    );
                    let alignmentTries = 0;
                    for (;;) {
                        let seconds = originalSeconds;
                        let hours = Math.floor(seconds / 3600);
                        seconds -= hours * 3600;
                        let minutes = Math.floor(seconds / 60);
                        seconds -= minutes * 60;

                        console.log(`Jumping to ${hours}:${minutes}:${seconds}`);

                        if (progressCallback)
                            progressCallback({
                                sectorsRead: finalData.length,
                                totalSectors: allSectors,
                                action: 'SEEK',
                            });

                        await this.finishDownload(); // Switch back to normal commands.
                        await sleep(1000);
                        await this.iface.stop();
                        await this.iface.gotoTime(track, hours, minutes, seconds);
                        await this.iface.stop();
                        await sleep(1000);
                        await this.startDownload(track); // Switch to ATRAC recovery.

                        // TODO:
                        // Use tron_twai_task to freeze the USB task until a correct flag is emitted
                        await sleep(10000); // Wait for the DRAM cache to fill up.

                        let alignmentPosition = -1;
                        await this.setSectorToRead(0);

                        let syncSector = await this.readNextSector();
                        let position = Array.from(syncSector.slice(20 - 8, 20 - 5));
                        console.log(`After moving the head, position is ${position.map((n) => n.toString(16).padStart(2, '0')).join('')}`);

                        let i = 0;
                        for (let data of sectorPositionsRead.reverse()) {
                            if (arrayShallowEquals(data, position)) {
                                alignmentPosition = i + 1;
                                break;
                            }
                            i++;
                        }

                        if (alignmentPosition === -1) {
                            // Cannot align.
                            if (alignmentTries < 3) {
                                alignmentTries++;
                                originalSeconds -= 2; // Try to align
                                continue;
                            }
                            console.log("DEBUG");
                            console.log("Could not align!");
                            console.log(`originalSeconds=${originalSeconds}`);
                            console.log(`syncSector=${Array.from(syncSector).map((n) => n.toString(16).padStart(2, '0')).join('')}`);
                            console.log(`sectorPositionsRead=${sectorPositionsRead.join(', ')}`);
                            console.log("DEBUG END");
                            await this.finishDownload();
                            throw new Error('Cannot align!');
                        }
                        sector = 0;
                        console.log(`Aligned! Running ${alignmentPosition} sectors behind!`);
                        await this.setSectorToRead(alignmentPosition);
                        break;
                    }
                } else {
                    // It's a valid ATRAC-containing sector.
                    // Add its position to the list of already done sectors.
                    sectorPositionsRead.push(currentPosition);
                    if (format.startsWith('LP')) {
                        // It's LP - remove the SP compatibility bytes.
                        // There are 12 zero-bytes at the start or each frame
                        // and 8 at the end.
                        const sectorAsArray = Array.from(sectorContent.slice(20));
                        for (let frame = 10; frame >= 0; frame--) {
                            const frameStartAddress = frame * 212; // 212 - one ATRAC sound frame.
                            sectorAsArray.splice(frameStartAddress + 212 - 8, 8);
                            sectorAsArray.splice(frameStartAddress, 12);
                        }
                        finalData.push(new Uint8Array(sectorAsArray));
                    } else {
                        finalData.push(sectorContent.slice(20));
                    }
                    let thisCluster = (currentPosition[0] << 8) | currentPosition[1];
                    if (progressCallback)
                        progressCallback({
                            sectorsRead: finalData.length,
                            totalSectors: allSectors,
                            action: 'READ',
                            sector: `${thisCluster.toString(16).padStart(4, '0')}.${currentPosition[2].toString(16).padStart(2, '0')}`,
                        });
                }
            }

            // Sanity check fail.
            // Recover whatever possible.
            return concatUint8Arrays(await createHeader(), ...finalData);
        } catch (ex) {
            await this.finishDownload(); // If anything goes wrong, at least try to put the device back into a usable state.
            throw ex;
        }
    }
}
