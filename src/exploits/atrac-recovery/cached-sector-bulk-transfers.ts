import { cleanWrite, display, DisplayMode, MemoryType, writeOfAnyLength } from 'netmd-js';
import { VersionPropertyStore } from '../../exploit';
import { formatUIntQuery } from '../../utils';
import { USBCodeExecution } from '../usb-code-execution';
import { AtracRecovery } from './atrac-recovery-interface';

/* The original non-ATRAC bulk transfer initialization code was written by Sir68k (https://github.com/Sir68k). */
export class CachedSectorBulkDownload extends AtracRecovery {
    public static _name = 'CachedSectorBulkDownload';
    getPropertyStore(): VersionPropertyStore {
        return {
            _macros: {
                "*": {
                    ldr1: {
                        code: `
                            ldr r0, %macro_argument_0
                            ldr r1, [ r0 ]
                        `,
                        properties: {},
                    },
                    wrr1: {
                        code: `
                            ldr r0, %macro_argument_0
                            str r1, [ r0 ]
                        `,
                        properties: {},
                    },
                    wrim: {
                        code: `
                            mov r1, %macro_argument_1
                            @wrr1 %macro_argument_0
                        `,
                        properties: {},
                    },
                    wrc: {
                        code: `
                            ldr r1, %macro_argument_1
                            @wrr1 %macro_argument_0
                        `,
                        properties: {},
                    },
                },
            },
            init_code: {
                'S*': `
                    _loader:
                        push { r3, r4, r5, r6, r7, lr }

                        ldr r3, patch_spot
                        ldr r4, patch_content
                        mov r5, #$patch_slot_1
                        bl _patch
                        
                        ldr r3, patch_spot_2
                        ldr r4, resident_code_address
                        mov r5, #$patch_slot_2
                        bl _patch
                        
                        pop { r3, r4, r5, r6, r7, lr }
                        bx lr
                        
                        patch_content: .word 0x47004800
                        @bridge word patch_spot patch_spot_2 resident_code_address
                    _patch:
                        @patch
                `,
            },
            prep_code_loader: {
                'S*': `
                    ldr r0, prep_code_address
                    bx r0
                    @bridge word prep_code_address
                `,
            },
            prep_code: {
                'S*': `
                    @wrim sector_offset, #0x0

                    @ldr1 p_dma_mode
                    bic r1, r1, #1
                    @wrr1 p_dma_mode
                    @wrim p_dma_x, #0
                    @wrim p_z, #0x21
                    @wrc p_dma_mode, const_p_dma_mode

                    @wrc p_usb_mode, const_p_usb_mode
                    @wrc p_uo_100, const_p_uo_100
                    @wrc p_uo_104, const_p_uo_104
                    @wrim p_uo_108, #0x100

                    @ldr1 p_uo_108
                    bic r1, r1, #512
                    @wrr1 p_uo_108
                    
                    @ldr1 p_uo_100
                    mov r0, #0x100
                    orr r1, r1, r0
                    @wrr1 p_uo_100
                    
                    ; USB and DMA prepared already
                    ; Now load the first atrac sector
                    ldr r0, sector_start
                    ldr r0, [ r0 ]
                    mov r1, #0
                    ldr r2, sector_buffer
                    mov r3, #2352
                    push { r4, lr }
                    @blxar r4, $function_read_atrac_dram
                    @ldr1 sector_start
                    add r1, r1, #1
                    @wrr1 sector_start

                    pop { r4, lr }
                    bx lr

                    const_p_dma_mode:   .word 0x33D0040
                    const_p_usb_mode:   .word 0x7310100
                    const_p_uo_100:     .word 0x800
                    const_p_uo_104:     .word 0xf301

                    @bridge word sector_start sector_offset sector_buffer
                    @bridge word p_dma_mode p_dma_x p_z p_usb_mode p_uo_100 p_uo_104 p_uo_108
                `,
            },
            bulk_transfer_code: {
                'S*': `
                    @fw_compat_bridge
                    ; The resident code responsible for handling bulk transfers
                    ; Main check
                    @ldr1 p_usb_state
                    lsrs r1, r1, #0x1a
                    bcc return

                    ; Main non-interrupt loop
                    loop:
                        @ldr1 p_uo_104
                        lsrs r1, r1, #9
                        bcc loop
                        
                        @wrim p_uo_104, #0x100

                        @ldr1 sector_offset
                        mov r0, #608
                        cmp r1, r0
                        bhs next_sector

                        send_sector:
                            @wrc p_uo_100, const_p_uo_100
                            @ldr1 sector_offset
                            lsl r1, r1, #2 ; *4
                            ldr r0, sector_buffer
                            add r1, r1, r0
                            @wrr1 p_dma_src
                            @wrc p_dma_dst, p_uo_114
                            @wrim p_dma_count, #32

                            @wrc p_dma_mode, const_p_dma_mode
                            @ldr1 sector_offset
                            add r1, r1, #32
                            @wrr1 sector_offset
                            b loop

                        next_sector:
                            ldr r0, sector_start
                            ldr r0, [ r0 ]
                            ldr r1, sector_end
                            ldr r1, [ r1 ]
                            cmp r0, r1
                            bhs return_and_undo

                            @ldr1 sector_start
                            push { r1 }
                            add r1, r1, #1
                            @wrr1 sector_start
                            pop { r0 }
                            mov r1, #0
                            ldr r2, sector_buffer
                            mov r3, #2352
                            @blxar r4, $function_read_atrac_dram
                            @wrim sector_offset, #0
                            b send_sector

                    return_and_undo:
                        mov r0, #12
                        mov r1, #16
                        ;@blxar r2, $tron_set_flg


                    return:
                        pop { r4, r5, r7 }
                        pop { r3 }
                        bx r3
                    
                    const_p_uo_100:         .word 0x0800100
                    const_p_dma_mode:       .word 0x33D0041
                    @bridge word sector_offset sector_start sector_end sector_buffer
                    @bridge word p_usb_state p_uo_104 p_uo_100 p_uo_114 p_dma_src p_dma_dst p_dma_count p_dma_mode
                `,
            },
            resident_code_address:  { 'S*': 0x02005a00 },
            prep_code_address:      { 'S*': 0x02005600 },
            sector_offset:          { 'S*': 0x02005d00 },
            sector_start:           { 'S*': 0x02005d04 },
            sector_end:             { 'S*': 0x02005d08 },
            sector_buffer:          { 'S*': 0x02006000 },
            patch_slot_1:           { '*':  this.patchSlot1 },
            patch_slot_2:           { '*':  this.patchSlot2 },

            // USB
            p_usb_state:            { "S*": 0x0380c010 },
            p_usb_mode:             { "S*": 0x0380c014 },
            p_uo_100:               { "S*": 0x0380c100 },
            p_uo_104:               { "S*": 0x0380c104 },
            p_uo_108:               { "S*": 0x0380c108 },
            p_uo_10c:               { "S*": 0x0380c10c },
            p_uo_114:               { "S*": 0x0380c114 },

            // DMA
            p_dma_src:              { 'S*': 0x03803000 },
            p_dma_dst:              { 'S*': 0x03803004 },
            p_dma_count:            { 'S*': 0x03803008 },
            p_dma_mode:             { 'S*': 0x0380300c },
            p_dma_x:                { 'S*': 0x03803044 },
            p_z:                    { 'S*': 0x03804040 },

            patch_spot:             { "S1.600": 0x000780a0 },
            patch_spot_2:           { "S1.600": 0x000780a4 },
            function_read_atrac_dram: {
                'S1.600': 0x000781fd,
                'S1.500': 0x00077805,
                'S1.400': 0x00077131,
                'S1.300': 0x00073a71,
                'S1.200': 0x000723bd,
                'S1.100': 0x00071a35,
                'S1.000': 0x00078365,
            },
        };
    }

    currentTrack = -1;
    patchSlot1: number = -1;
    patchSlot2: number = -1;
    cachedSectors: Uint8Array = new Uint8Array();
    cachedSectorsPtr: number = 0;
    currentSector: number = 0;

    async init() {
        await super.init();
        this.patchSlot1 = this.stateManager.getIncrementalPatchNumber();
        this.patchSlot2 = this.stateManager.getIncrementalPatchNumber();
        const usbExecution = await this.stateManager.require(USBCodeExecution);
        await writeOfAnyLength(
            this.factoryIface,
            this.getProperty("prep_code_address"),
            this.assembleProperty("prep_code"),
            MemoryType.MAPPED
        );
        await writeOfAnyLength(
            this.factoryIface,
            this.getProperty("resident_code_address"),
            this.assembleProperty("bulk_transfer_code"),
            MemoryType.MAPPED
        );
        await usbExecution.execute(this.assembleProperty('init_code'));
        console.log("INIT OK");
    }

    async reloadBuffer(callback?: (data: {read: number, length: number}) => void, sectorsCount = 900){
        await cleanWrite(
            this.factoryIface,
            this.getProperty("sector_start"),
            formatUIntQuery("%<d", this.currentSector),
            MemoryType.MAPPED
        );
        await cleanWrite(
            this.factoryIface,
            this.getProperty("sector_end"),
            formatUIntQuery("%<d", this.currentSector + sectorsCount),
            MemoryType.MAPPED
        );
        console.log(`[BULK]: Set boundaries to ${this.currentSector} -> ${this.currentSector + sectorsCount}`);
        await (await this.stateManager.require(USBCodeExecution))
            .execute(this.assembleProperty("prep_code_loader"));
        this.cachedSectorsPtr = 0;
        this.cachedSectors = new Uint8Array(
            await this.stateManager.iface.netMd.readBulkToArray(
                sectorsCount * 2432,
                sectorsCount * 2432 / 2,
                callback && ((length, read) => callback({ read: Math.floor(read / 2432), length: sectorsCount }))
            )
        );
    }

    async readNextSector(callback?: (data: {read: number, length: number}) => void): Promise<Uint8Array> {
        if (this.currentTrack === -1) throw new Error('You need to startDownload() first');
        if (this.cachedSectorsPtr >= this.cachedSectors.length){
            await this.reloadBuffer(callback);
        }
        const slice = this.cachedSectors.slice(this.cachedSectorsPtr, this.cachedSectorsPtr + 2352);
        this.currentSector++;
        this.cachedSectorsPtr += 2432;
        return slice;
    }

    protected async readAlignmentSector(): Promise<Uint8Array> {
        if (this.currentTrack === -1) throw new Error('You need to startDownload() first');
        if(this.cachedSectorsPtr >= this.cachedSectors.length){
            await this.reloadBuffer(undefined, 1);
        }
        return this.cachedSectors;
    }

    async setSectorToRead(sector: number): Promise<void> {
        if (this.currentTrack === -1) throw new Error('You need to startDownload() first');
        this.currentSector = sector;
        // Force cache reload on next sector
        this.cachedSectorsPtr = this.cachedSectors.length + 1;
    }

    async startDownload(track: number): Promise<void> {
        await display(this.stateManager.factoryIface, 'ACCESS', true);
        this.currentTrack = track;
    }

    async finishDownload(): Promise<void> {
        await this.factoryIface.setDisplayMode(DisplayMode.DEFAULT);
        this.currentTrack = -1;
    }
}
