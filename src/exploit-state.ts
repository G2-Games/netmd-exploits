import { getDescriptiveDeviceCode, NetMDFactoryInterface, NetMDInterface } from 'netmd-js';
import { Assembler } from './assembler/assembler';
import { CORE_MACROS } from './assembler/core-macros';
import { Exploit, ExploitConstructor, PatchError } from './exploit';

export class ExploitStateManager {
    loadedList: { [key: string]: Exploit } = {};
    patchNumber: number = 0;
    protected constructor(
        public iface: NetMDInterface,
        public factoryIface: NetMDFactoryInterface,
        public versionCode: string,
        public armAssembler: Assembler
    ) {}

    public getIncrementalPatchNumber() {
        let thisPatch = this.patchNumber++;
        if (this.patchNumber > this.getMaxPatchesAmount()) {
            throw new PatchError(`Tried exceeding max. patches amount (${this.getMaxPatchesAmount()}). Patch memory full.`);
        }
        return thisPatch;
    }

    public getMaxPatchesAmount() {
        return this.versionCode.startsWith('R') ? 0x4 : 0x8;
    }

    public async require<T extends Exploit>(subclassConstructor: ExploitConstructor<T>): Promise<T> {
        if (subclassConstructor._name in this.loadedList) {
            return this.loadedList[subclassConstructor._name] as T;
        } else {
            let newInstance = new subclassConstructor(this);
            await newInstance.init();
            this.loadedList[subclassConstructor._name] = newInstance;
            return newInstance;
        }
    }

    public static async create(iface: NetMDInterface, factoryIface?: NetMDFactoryInterface) {
        if (!factoryIface) {
            factoryIface = await iface.factory();
        }
        return new ExploitStateManager(
            iface,
            factoryIface,
            await getDescriptiveDeviceCode(factoryIface),
            await Assembler.create(CORE_MACROS)
        );
    }
}
