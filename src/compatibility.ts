import { Exploit, ExploitConstructor } from './exploit';
import { DeviceType, ExploitStateManager } from './exploit-state';
import { KillEepromWrite } from './exploits/kill-eeprom-writes';
import { SPFasterUpload } from './exploits/sp-faster-upload';

import { USBCodeExecution } from './exploits/usb-code-execution';
import {
    CachedSectorControlDownload,
    CachedSectorNoRamControlDownload,
    FirmwareDumper,
    ForceTOCEdit,
    Tetris,
    CachedSectorBulkDownload,
    WaitForDiscToStopSpinning,
    AtracRecovery,
    SPUpload,
} from './exploits';
import { isVersionMatchingFormat } from './utils';

type AbstractExploitConstructor<T extends Exploit> = (abstract new (statemanager: ExploitStateManager) => T) & { _name: string };

const CompatibilityTable: { [key: string]: (string | ExploitConstructor<Exploit>)[] } = {
    [FirmwareDumper._name]: ['*'],
    [USBCodeExecution._name]: [
        'S1.600',
        'S1.500',
        'S1.400',
        'S1.300',
        'S1.200',
        'S1.100',
        'S1.000',

        'R1.400',
        'R1.300',
        'R1.200',
        'R1.100',
        'R1.000',
    ],
    [CachedSectorControlDownload._name]: [
        'S1.600',
        'S1.500',
        'S1.400',
        'S1.300',
        'S1.200',
        'S1.100',
        'S1.000',

        // Although this method works for Type-R devices, it puts them into an unstable state.
        // 'R1.400',
        // 'R1.300',
        // 'R1.200',
        // 'R1.100',
        // 'R1.000',

        USBCodeExecution,
        WaitForDiscToStopSpinning,
    ],
    [CachedSectorNoRamControlDownload._name]: [
        'S1.600',
        'S1.500',
        'S1.400',
        'S1.300',
        'S1.200',
        'S1.100',
        'S1.000',

        'R1.400',
        'R1.300',
        'R1.200',
        'R1.100',
        'R1.000',

        USBCodeExecution,
        WaitForDiscToStopSpinning,
    ],
    [ForceTOCEdit._name]: [
        'S1.600',
        'S1.500',
        'S1.400',
        'S1.300',
        'S1.200',
        'S1.100',
        'S1.000',

        'R1.400',
        'R1.300',
        'R1.200',
        'R1.100',
        'R1.000',

        USBCodeExecution,
    ],
    [Tetris._name]: [
        
        'S1.600',
        'S1.500',
        'S1.400',
        'S1.300',
        'S1.200',
        'S1.100',
        'S1.000',

        'HWID 09',
        'HWID 08',
        'HWID 07',
        'HWID 06',
        'HWID 05',
        'HWID 04',
        
        USBCodeExecution,
        
    ],
    [KillEepromWrite._name]: [
        'S1.000',
        'S1.100',
        'S1.200',
        'S1.300',
        'S1.400',
        'S1.500',
        'S1.600',

        'R1.000',
        'R1.100',
        'R1.200',
        'R1.300',
        'R1.400',

        USBCodeExecution,
    ],
    [CachedSectorBulkDownload._name]: [
        'S1.600',
        'S1.500',
        'S1.400',
        'S1.300',
        'S1.200',
        'S1.100',
        'S1.000',

        USBCodeExecution,
        WaitForDiscToStopSpinning,
    ],
    [SPFasterUpload._name]: [
        'S1.600',
        'S1.500',
        'S1.400',
        'S1.300',
        'S1.200',
        'S1.100',
        'S1.000',

        'HWID 09',
        'HWID 08',
        'HWID 05',
        'HWID 04' 
    ],
    [WaitForDiscToStopSpinning._name]: [
        'S1.600',
        'S1.500',
        'S1.400',
        'S1.300',
        'S1.200',
        'S1.100',
        'S1.000',

        'R*', // It just waits for 10 seconds on type-R devices.

        USBCodeExecution,
    ],
    [SPUpload._name]: ['S1.600'],
};

const BestSuitedTable: { [key: string]: ExploitConstructor<Exploit>[] } = {
    [AtracRecovery._name]: [CachedSectorBulkDownload, CachedSectorControlDownload, CachedSectorNoRamControlDownload],
};

export function isCompatible<T extends Exploit>(exploit: ExploitConstructor<T> | AbstractExploitConstructor<T>, deviceType: DeviceType) {
    const deviceTypeString = JSON.stringify(deviceType);

    if (Object.keys(BestSuitedTable).includes(exploit._name)) {
        return getBestSuited(exploit, deviceType) !== null;
    }
    let compatibles = CompatibilityTable[exploit._name];
    if (!compatibles)
        throw new Error(`Cannot check compatibility of ${exploit._name} as it hasn't been included in the compatibility table`);
    let dependencies = compatibles.filter((n) => (n as any)._name !== undefined);
    // All dependencies have to be compatible.
    if (!dependencies.every((n) => isCompatible(n as any, deviceType))) {
        console.log(`Checking compatibility of ${exploit._name} with ${deviceTypeString} - Deps-incompatible!`);
        return false;
    }

    const compatibleVersions = CompatibilityTable[exploit._name].filter((n) => typeof n === 'string' && !n.startsWith('HWID ')) as string[];
    const compatibleHWIDs = CompatibilityTable[exploit._name]
        .filter((n) => typeof n === 'string' && n.startsWith('HWID '))
        .map((n) => parseInt((n as string).substring(5), 16));

    if (
        (compatibleHWIDs.length === 0 || compatibleHWIDs.some((e) => e === deviceType.hwid)) &&
        compatibleVersions.some((e) => isVersionMatchingFormat(e, deviceType.versionCode))
    ) {
        console.log(`Checking compatibility of ${exploit._name} with ${deviceTypeString} - Compatible!`);
        return true;
    }

    console.log(`Checking compatibility of ${exploit._name} with ${deviceTypeString} - Incompatible!`);
    return false;
}

export function getBestSuited<T extends Exploit>(
    exploitFamily: AbstractExploitConstructor<T>,
    deviceType: DeviceType
): ExploitConstructor<T> | null {
    if (!Object.keys(BestSuitedTable).includes(exploitFamily._name)) {
        return null;
    }
    for (let exploitConstructor of BestSuitedTable[exploitFamily._name]) {
        if (isCompatible(exploitConstructor, deviceType)) {
            return exploitConstructor as ExploitConstructor<T>;
        }
    }
    return null;
}
