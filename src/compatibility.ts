import { Exploit, ExploitConstructor } from './exploit';
import { ExploitStateManager } from './exploit-state';
import { AtracRecovery, CachedSectorControlDownload, FirmwareDumper, ForceTOCEdit, Tetris, CachedSectorBulkDownload, WaitForDiscToStopSpinning } from './exploits';
import { KillEepromWrite } from './exploits/kill-eeprom-writes';
import { SPFasterUpload } from './exploits/sp-faster-upload';

import { USBCodeExecution } from './exploits/usb-code-execution';
import { isVersionMatchingFormat } from './utils';

type AbstractExploitConstructor<T extends Exploit>  = (abstract new (statemanager: ExploitStateManager) => T) & { _name: string };

const CompatibilityTable: { [key: string]: (string | ExploitConstructor<Exploit>)[] } = {
    [FirmwareDumper._name]:                 ['*'],
    [USBCodeExecution._name]:               ['S1.600', 'S1.500', 'S1.400', 'S1.300', 'S1.200', 'S1.100', 'S1.000', 'R1.100'],
    [CachedSectorControlDownload._name]:    ['S1.600', 'S1.500','S1.400', 'S1.300', 'S1.200', 'S1.100', 'S1.000', 'R1.100', USBCodeExecution, WaitForDiscToStopSpinning],
    [ForceTOCEdit._name]:                   ['S1.600', 'S1.500','S1.400', 'S1.300', 'S1.200', 'S1.100', 'S1.000', USBCodeExecution],
    [Tetris._name]:                         [], // 'S1.600', 'S1.500','S1.400', 'S1.300', 'S1.100', 'S1.000', USBCodeExecution
    [KillEepromWrite._name]:                ['S1.600', USBCodeExecution],
    [CachedSectorBulkDownload._name]:       ['S1.600', USBCodeExecution, WaitForDiscToStopSpinning],
    [SPFasterUpload._name]:                 ['S1.600'], /* TODO: Change this to only allow non-4x devices */
    [WaitForDiscToStopSpinning._name]:      ['S1.600', 'S1.500', 'S1.400', 'S1.300', 'S1.200', 'S1.100', 'S1.000', 'R1.100', USBCodeExecution],
};

const BestSuitedTable: { [key: string]: ExploitConstructor<Exploit>[] } = {
    [AtracRecovery._name]: [ CachedSectorBulkDownload, CachedSectorControlDownload ],
}

export function isCompatible<T extends Exploit>(
    exploit: ExploitConstructor<T> | AbstractExploitConstructor<T>,
    version: string
) {
    if(getBestSuited(exploit, version) !== null) return true;
    let compatibles = CompatibilityTable[exploit._name];
    if (!compatibles)
        throw new Error(`Cannot check compatibility of ${exploit._name} as it hasn't been included in the compatibility table`);
    let dependencies = compatibles.filter((n) => (n as any)._name !== undefined);
    // All dependencies have to be compatible.
    if (!dependencies.every((n) => isCompatible(n as any, version))) {
        console.log(`Checking compatibility of ${exploit._name} with ${version} - Deps-incompatible!`);
        return false;
    }
    for (let compatibleVersion of CompatibilityTable[exploit._name]) {
        if (typeof compatibleVersion === 'string') {
            if (isVersionMatchingFormat(compatibleVersion, version)) {
                console.log(`Checking compatibility of ${exploit._name} with ${version} - Compatible!`);
                return true;
            }
        }
    }
    console.log(`Checking compatibility of ${exploit._name} with ${version} - Incompatible!`);
    return false;
}

export function getBestSuited<T extends Exploit>(
    exploitFamily: AbstractExploitConstructor<T>,
    version: string
) {
    if (!Object.keys(BestSuitedTable).includes(exploitFamily._name)){
        return null;
    }
    for(let exploitConstructor of BestSuitedTable[exploitFamily._name]){
        if(isCompatible(exploitConstructor, version)){
            return exploitConstructor;
        }
    }
    return null;
}
