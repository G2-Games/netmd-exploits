import { VersionPropertyStore } from '../exploit';
import { getFromVersionStore } from '../utils';
import { Keystone, MODE_ARM, ARCH_ARM, MODE_THUMB, construct, version } from './keystone-arm';

export interface Macro {
    code: string;
    properties: VersionPropertyStore;
}

export class AssemblerSyntaxError extends Error {
    constructor(message: string) {
        super(message);
        Object.setPrototypeOf(this, AssemblerSyntaxError.prototype);
    }
}

export class Assembler {
    private keystone: Keystone;

    public static async create(macros: { [key: string]: Macro }, mode: 'ARM' | 'THUMB' = 'ARM') {
        await construct();
        return new Assembler(macros, mode);
    }

    public static async version() {
        await construct();
        return await version();
    }

    private constructor(private macros: { [key: string]: Macro }, mode: 'ARM' | 'THUMB' = 'ARM') {
        this.keystone = new Keystone(ARCH_ARM, mode === 'ARM' ? MODE_ARM : MODE_THUMB);
    }

    processCode(code: string, versionProps: VersionPropertyStore, versionCode: string, variablesPassed: { [key: string]: string }) {
        Object.entries(variablesPassed).forEach(([from, to]) => (code = code.replace(new RegExp(`%${from}`, 'g'), to)));

        let lines = code.split('\n');
        let newLines = lines.map((line) => {
            line = line.trim();
            let commentStart = line.indexOf(';');
            if (commentStart !== -1) {
                line = line.substring(0, commentStart);
            }

            if (line.startsWith('@')) {
                // Macro
                let [name, ...args] = line.substring(1).split(' ');
                args = args.map((n) => (n.endsWith(',') ? n.substring(0, n.length - 1) : n));

                let thisMacro = this.macros[name];
                if (!thisMacro) {
                    throw new AssemblerSyntaxError(`The mixin: ${name} doesn't exist`);
                }

                // Parent inherits all children's VersionStore props
                for (let [k, v] of Object.entries(thisMacro.properties)) {
                    if (!(k in versionProps)) {
                        versionProps[k] = v;
                    }
                }

                // Variables don't get inherited by parent.
                let processedVariables = {
                    ...variablesPassed,
                };
                for (let argIdx in args) {
                    processedVariables[`macro_argument_${argIdx}`] = args[argIdx];
                }
                line = this.processCode(thisMacro.code, versionProps, versionCode, processedVariables);
            }
            return line;
        });

        code = newLines.join('\n');

        Object.keys(versionProps)
            .filter((n) => code.includes('$' + n))
            .forEach(
                (n) =>
                    (code = code.replace(new RegExp(`\\$${n}`, 'g'), () => {
                        let i = getFromVersionStore(versionProps, versionCode, n);
                        if (typeof i === 'number') {
                            return '0x' + i.toString(16);
                        }
                        return i;
                    }))
            );

        return code;
    }

    assemble(code: string) {
        return this.keystone.asm(code, 0);
    }
}
