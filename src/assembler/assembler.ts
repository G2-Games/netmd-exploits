import { VersionPropertyStore } from '../exploit';
import { getFromVersionStore } from '../utils';
import { Keystone, MODE_ARM, ARCH_ARM, MODE_THUMB, construct, version } from './keystone-arm';

export interface Macro {
    code: string | ((
        versionProps: VersionPropertyStore,
        versionCode: string,
        variablesPassed: { [key: string]: string },
        ...args: string[]
    ) => string);
    properties: VersionPropertyStore;
}

export class AssemblerSyntaxError extends Error {
    constructor(message: string) {
        super(message);
        Object.setPrototypeOf(this, AssemblerSyntaxError.prototype);
    }
}

export class Assembler {
    private keystone: Keystone;

    public static async create(macros: { [key: string]: Macro }, mode: 'ARM' | 'THUMB' = 'ARM') {
        await construct();
        return new Assembler(macros, mode);
    }

    public static async version() {
        await construct();
        return await version();
    }

    private constructor(private macros: { [key: string]: Macro }, mode: 'ARM' | 'THUMB' = 'ARM') {
        this.keystone = new Keystone(ARCH_ARM, mode === 'ARM' ? MODE_ARM : MODE_THUMB);
    }

    processCode(
        code: string,
        versionProps: VersionPropertyStore,
        versionCode: string,
        variablesPassed: { [key: string]: string },
        ownMacros: { [key: string]: Macro } = {}
    ) {
        Object.entries(variablesPassed).forEach(([from, to]) => (code = code.replace(new RegExp(`%${from}`, 'g'), to)));

        let lines = code.split('\n');
        let newLines = lines.map((line) => {
            let trimmed = line.trim();
            if (trimmed.startsWith('@')) {
                // Macro
                let [name, ...args] = trimmed.substring(1).split(' ');
                args = args.map((n) => (n.endsWith(',') ? n.substring(0, n.length - 1) : n));

                let thisMacro = this.macros[name] || ownMacros[name];
                if (!thisMacro) {
                    throw new AssemblerSyntaxError(`The macro: ${name} doesn't exist`);
                }

                // Parent inherits all children's VersionStore props
                for (let [k, v] of Object.entries(thisMacro.properties)) {
                    if (!(k in versionProps)) {
                        versionProps[k] = v;
                    }
                }
                let macroCode = thisMacro.code;
                if(typeof macroCode === 'function'){
                    line = macroCode(versionProps, versionCode, variablesPassed, ...args).trim();
                }else{

                    // Variables don't get inherited by parent.
                    let processedVariables = {
                        ...variablesPassed,
                    };
                    for (let argIdx in args) {
                        processedVariables[`macro_argument_${argIdx}`] = args[argIdx];
                    }
                    line = this.processCode(macroCode, versionProps, versionCode, processedVariables, ownMacros).trim();
                }

                line = `; Unwound macro ${name} (@${name} ${args.join(', ')})\n${line}\n; Macro ${name} end\n`;
            }
            return line;
        });

        let readableCode = newLines.join('\n');

        Object.keys(versionProps)
            .sort((a, b) => b.length - a.length)
            .filter((n) => readableCode.includes('$' + n))
            .forEach(
                (n) =>
                    (readableCode = readableCode.replace(new RegExp(`\\$${n}`, 'g'), () => {
                        let i = getFromVersionStore(versionProps, versionCode, n);
                        if (typeof i === 'number') {
                            return '0x' + i.toString(16);
                        }
                        return i;
                    }))
            );

        return readableCode;
    }

    assemble(code: string) {
        return this.keystone.asm(code, 0);
    }

    removeComments(code: string){
        return code.split("\n").map(line => {
            line = line.trim();
            let commentStart = line.indexOf(';');
            if (commentStart !== -1) {
                line = line.substring(0, commentStart);
            }
            return line;
        }).join('\n');
    }
}
