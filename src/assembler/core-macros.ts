import { VersionPropertyStore } from '../exploit';
import { getFromVersionStore } from '../utils';
import { Macro } from './assembler';

export const CORE_MACROS: { [key: string]: Macro } = {
    blxar: {
        code: `
            add %macro_argument_0, pc, #0xc
            mov lr, %macro_argument_0
            ldr %macro_argument_0, [ pc ]
            bx %macro_argument_0
            .word %macro_argument_1
        `,
        properties: {},
    },
    blxa: {
        code: `
            @blxar r7, %macro_argument_0
        `,
        properties: {},
    },
    bxar: {
        code: `
            ldr %macro_argument_0, [ pc ]
            bx %macro_argument_0
            .word %macro_argument_1
        `,
        properties: {},
    },
    bxa: {
        code: `
            @bxar r7, %macro_argument_0
        `,
        properties: {},
    },
    bridge: {
        code: (versionProps: VersionPropertyStore, versionCode: string, variablesPassed: { [key: string]: string; }, ...args: string[]) => {
            const [ type, ...props ] = args;
            if(!["word", "hword", "byte", "ascii"].includes(type)) throw new Error("Unsupported type given");
            let data = "";
            for(let prop of props){
                let value = getFromVersionStore(versionProps, versionCode, prop);
                if(typeof value === "string"){
                    value = `"${value.replace("\"", "\\\"")}"`;
                }
                data += `${prop}: .${type} ${value}\n`;
            }
            return data;
        },
        properties: {},
    },
    fw_compat_bridge: {
        code: ``,
        properties: {
            tron_ter_task: { //tron_ter_tsk
                'S1.600': 0x0007c5c1,
                'S1.500': 0x0007bb41,
                'S1.400': 0x0007b481,
                'S1.300': 0x00077c19,
                'S1.200': 0x00076449,
                'S1.100': 0x00075a3d,
                'S1.000': 0x0007c731,
            },
            tron_set_flg: {
                'S1.600': 0x0007c095,
                'S1.500': 0x0007b615,
                'S1.400': 0x0007af55,
                'S1.300': 0x000776ed,
                'S1.200': 0x00075f1d,
                'S1.100': 0x00075511,
                'S1.000': 0x0007c205,
                'R1.100': 0x0005cb59,
            },
            tron_clr_flg: {
                'S1.600': 0x0007c2c5,
                'S1.500': 0x0007b845,
                'S1.400': 0x0007b185,
                'S1.300': 0x0007791d,
                'S1.200': 0x0007614d,
                'S1.100': 0x00075741,
                'S1.000': 0x0007c435,
                'R1.100': 0x0005ccc5,
            },
            tron_twai_flg: {
                'S1.600': 0x0007c319,
                'S1.500': 0x0007b899,
                'S1.200': 0x000761a1,
                'S1.100': 0x00075795,
                'S1.000': 0x0007c489,
                'S1.400': 0x0007b1d9,
                'S1.300': 0x00077971,
                'R1.100': 0x0005c889,
            },
            usb_do_response: { //usbDoResponse
                'S1.600': 0x00077a3d,
                'S1.500': 0x00077045,
                'S1.400': 0x00076971,
                'S1.300': 0x000732c1,
                'S1.200': 0x00071ca9,
                'S1.100': 0x00071321,
                'S1.000': 0x00077ba5,

                'R1.100': 0x00059715,
            },
            g_usb_buff: { // These are easy to find in handleUnitInfo
                'S1.600': 0x02001170,
                'S1.500': 0x02001158,
                'S1.400': 0x0200113c,
                'S1.300': 0x0200102c,
                'S1.200': 0x02001018,
                'S1.100': 0x02001014,
                'S1.000': 0x0200117c,

                'R1.100': 0x02004104,
            },
            g_DiscStateStruct: {
                'S1.600': 0x020001e8,
                'S1.500': 0x020001e8,
                'S1.400': 0x020001e8,
                'S1.300': 0x020001d8,
                'S1.200': 0x020001cc,
                'S1.100': 0x020001cc,
                'S1.000': 0x020001e8,

                'R1.100': 0x02000B38,
            },
        },
    },
    patch: {
        code: `
            ; r5:uint8_t  <- patch number
            ; r3:uint32_t <- address
            ; r4:uint32_t <- value
            
            ; Write 5, 12 to main control
            ldr r0, _patch_macro_control
            mov r1, #5
            strb r1, [ r0 ]
            mov r1, #12
            strb r1, [ r0 ]
            
            ldr r0, _patch_macro_base
            lsl r5, r5, #4
            add r0, r0, r5
            
            ; AND 0xFE with patch control
            ldr r1, [ r0 ]
            and r1, r1, #0xFE
            str r1, [ r0 ]
            
            ; AND 0xFD with patch control
            ldr r1, [ r0 ]
            and r1, r1, #0xFD
            str r1, [ r0 ], #4
            
            ; Write patch address
            str r3, [ r0 ], #4
            
            ; Write patch value
            str r4, [ r0 ]
            
            sub r0, r0, #8
            ldr r1, [ r0 ]
            orr r1, r1, #1
            str r1, [ r0 ]
            
            ; Write 5, 9 to main control
            ldr r0, _patch_macro_control
            mov r1, #5
            strb r1, [ r0 ]
            mov r1, #9
            strb r1, [ r0 ]
        
            bx lr

            _patch_macro_control: .word $_patchMacroControl
            _patch_macro_base: .word $_patchMacroBase
        `,
        properties: {
            _patchMacroBase: {
                '*': 0x03802000,
            },
            _patchMacroControl: {
                'R*': 0x03802040,
                'S*': 0x03802080,
            },
        },
    },
};
